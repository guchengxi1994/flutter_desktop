// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.21.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../files/virtual_folder.dart';
import '../files/vitrual_file.dart';
import '../frb_generated.dart';
import '../idiom/model.dart';
import '../native_sysinfo.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

String greet({required String name, dynamic hint}) =>
    RustLib.instance.api.greet(name: name, hint: hint);

Future<void> initSystem({required List<String> s, dynamic hint}) =>
    RustLib.instance.api.initSystem(s: s, hint: hint);

Future<String> getChangelogs({dynamic hint}) =>
    RustLib.instance.api.getChangelogs(hint: hint);

Future<String> rustBridgeSayHello({dynamic hint}) =>
    RustLib.instance.api.rustBridgeSayHello(hint: hint);

/// files
Future<int> newFile(
        {required String virtualPath,
        required String realPath,
        dynamic hint}) =>
    RustLib.instance.api
        .newFile(virtualPath: virtualPath, realPath: realPath, hint: hint);

Stream<NativeSysInfo> sysInfoStream({dynamic hint}) =>
    RustLib.instance.api.sysInfoStream(hint: hint);

Future<void> listenSysinfo({String? name, dynamic hint}) =>
    RustLib.instance.api.listenSysinfo(name: name, hint: hint);

Future<void> setIdiomPath({required String s, dynamic hint}) =>
    RustLib.instance.api.setIdiomPath(s: s, hint: hint);

Future<List<Idiom>> getIdioms({int? count, dynamic hint}) =>
    RustLib.instance.api.getIdioms(count: count, hint: hint);

Future<Idiom?> getOneIdiom({required int index, dynamic hint}) =>
    RustLib.instance.api.getOneIdiom(index: index, hint: hint);

Future<void> createNewTxt(
        {required String filename,
        required String openWith,
        int? folderId,
        dynamic hint}) =>
    RustLib.instance.api.createNewTxt(
        filename: filename, openWith: openWith, folderId: folderId, hint: hint);

Future<void> deleteFile({required int id, dynamic hint}) =>
    RustLib.instance.api.deleteFile(id: id, hint: hint);

Future<void> restoreFile({required int id, dynamic hint}) =>
    RustLib.instance.api.restoreFile(id: id, hint: hint);

Future<List<FileOrFolder>> getChildrenById({int? i, dynamic hint}) =>
    RustLib.instance.api.getChildrenById(i: i, hint: hint);
