#![allow(
    non_camel_case_types,
    unused,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::double_parens,
    non_snake_case,
    clippy::too_many_arguments
)]
// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.77.1.

use crate::api::*;
use core::panic::UnwindSafe;
use flutter_rust_bridge::*;
use std::ffi::c_void;
use std::sync::Arc;

// Section: imports

use crate::browser::history::BrowserHistory;
use crate::files::virtual_folder::FileOrFolder;
use crate::files::virtual_folder::VirtualFolder;
use crate::files::vitrual_file::VirtualFile;
use crate::idiom::model::Idiom;
use crate::idiom::practice::PracticeStatus;
use crate::native_sysinfo::NativeSysInfo;

// Section: wire functions

fn wire_get_changelogs_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_changelogs",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(get_changelogs()),
    )
}
fn wire_rust_bridge_say_hello_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "rust_bridge_say_hello",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(rust_bridge_say_hello()),
    )
}
fn wire_set_db_path_impl(port_: MessagePort, s: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_db_path",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_s = s.wire2api();
            move |task_callback| Ok(set_db_path(api_s))
        },
    )
}
fn wire_init_db_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "init_db",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(init_db()),
    )
}
fn wire_new_log_impl(
    port_: MessagePort,
    content: impl Wire2Api<String> + UnwindSafe,
    result: impl Wire2Api<Option<String>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_log",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_content = content.wire2api();
            let api_result = result.wire2api();
            move |task_callback| Ok(new_log(api_content, api_result))
        },
    )
}
fn wire_new_file_impl(
    port_: MessagePort,
    virtual_path: impl Wire2Api<String> + UnwindSafe,
    real_path: impl Wire2Api<String> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_file",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_virtual_path = virtual_path.wire2api();
            let api_real_path = real_path.wire2api();
            move |task_callback| Ok(new_file(api_virtual_path, api_real_path))
        },
    )
}
fn wire_sys_info_stream_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "sys_info_stream",
            port: Some(port_),
            mode: FfiCallMode::Stream,
        },
        move || move |task_callback| sys_info_stream(task_callback.stream_sink()),
    )
}
fn wire_listen_sysinfo_impl(port_: MessagePort, name: impl Wire2Api<Option<String>> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "listen_sysinfo",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_name = name.wire2api();
            move |task_callback| Ok(listen_sysinfo(api_name))
        },
    )
}
fn wire_set_json_path_impl(port_: MessagePort, s: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_json_path",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_s = s.wire2api();
            move |task_callback| Ok(set_json_path(api_s))
        },
    )
}
fn wire_set_cache_path_impl(port_: MessagePort, s: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_cache_path",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_s = s.wire2api();
            move |task_callback| Ok(set_cache_path(api_s))
        },
    )
}
fn wire_set_idiom_path_impl(port_: MessagePort, s: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "set_idiom_path",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_s = s.wire2api();
            move |task_callback| Ok(set_idiom_path(api_s))
        },
    )
}
fn wire_get_idioms_impl(port_: MessagePort, count: impl Wire2Api<Option<u64>> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_idioms",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_count = count.wire2api();
            move |task_callback| Ok(get_idioms(api_count))
        },
    )
}
fn wire_get_one_idiom_impl(port_: MessagePort, index: impl Wire2Api<usize> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_one_idiom",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_index = index.wire2api();
            move |task_callback| Ok(get_one_idiom(api_index))
        },
    )
}
fn wire_init_folder_impl(port_: MessagePort, s: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "init_folder",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_s = s.wire2api();
            move |task_callback| Ok(init_folder(api_s))
        },
    )
}
fn wire_create_new_txt_impl(
    port_: MessagePort,
    filename: impl Wire2Api<String> + UnwindSafe,
    open_with: impl Wire2Api<String> + UnwindSafe,
    folder_id: impl Wire2Api<Option<i64>> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "create_new_txt",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_filename = filename.wire2api();
            let api_open_with = open_with.wire2api();
            let api_folder_id = folder_id.wire2api();
            move |task_callback| Ok(create_new_txt(api_filename, api_open_with, api_folder_id))
        },
    )
}
fn wire_delete_file_impl(port_: MessagePort, id: impl Wire2Api<i64> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "delete_file",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_id = id.wire2api();
            move |task_callback| Ok(delete_file(api_id))
        },
    )
}
fn wire_restore_file_impl(port_: MessagePort, id: impl Wire2Api<i64> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "restore_file",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_id = id.wire2api();
            move |task_callback| Ok(restore_file(api_id))
        },
    )
}
fn wire_get_children_by_id_impl(port_: MessagePort, i: impl Wire2Api<Option<i64>> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_children_by_id",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_i = i.wire2api();
            move |task_callback| Ok(get_children_by_id(api_i))
        },
    )
}
fn wire_new_practice_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_practice",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(new_practice()),
    )
}
fn wire_update_practice_impl(
    port_: MessagePort,
    hit: impl Wire2Api<i64> + UnwindSafe,
    index: impl Wire2Api<i64> + UnwindSafe,
    row_id: impl Wire2Api<i64> + UnwindSafe,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "update_practice",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_hit = hit.wire2api();
            let api_index = index.wire2api();
            let api_row_id = row_id.wire2api();
            move |task_callback| Ok(update_practice(api_hit, api_index, api_row_id))
        },
    )
}
fn wire_get_last_practice_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "get_last_practice",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(get_last_practice()),
    )
}
fn wire_delete_3_days_ago_history_impl(port_: MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "delete_3_days_ago_history",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || move |task_callback| Ok(delete_3_days_ago_history()),
    )
}
fn wire_new_browser_history_impl(port_: MessagePort, s: impl Wire2Api<String> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "new_browser_history",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_s = s.wire2api();
            move |task_callback| Ok(new_browser_history(api_s))
        },
    )
}
fn wire_fetch_history_impl(port_: MessagePort, page: impl Wire2Api<i64> + UnwindSafe) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap(
        WrapInfo {
            debug_name: "fetch_history",
            port: Some(port_),
            mode: FfiCallMode::Normal,
        },
        move || {
            let api_page = page.wire2api();
            move |task_callback| Ok(fetch_history(api_page))
        },
    )
}
// Section: wrapper structs

// Section: static checks

// Section: allocate functions

// Section: related functions

// Section: impl Wire2Api

pub trait Wire2Api<T> {
    fn wire2api(self) -> T;
}

impl<T, S> Wire2Api<Option<T>> for *mut S
where
    *mut S: Wire2Api<T>,
{
    fn wire2api(self) -> Option<T> {
        (!self.is_null()).then(|| self.wire2api())
    }
}

impl Wire2Api<i64> for i64 {
    fn wire2api(self) -> i64 {
        self
    }
}

impl Wire2Api<u64> for u64 {
    fn wire2api(self) -> u64 {
        self
    }
}
impl Wire2Api<u8> for u8 {
    fn wire2api(self) -> u8 {
        self
    }
}

impl Wire2Api<usize> for usize {
    fn wire2api(self) -> usize {
        self
    }
}
// Section: impl IntoDart

impl support::IntoDart for BrowserHistory {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.visit_id.into_dart(),
            self.url.into_dart(),
            self.create_at.into_dart(),
            self.is_deleted.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for BrowserHistory {}

impl support::IntoDart for FileOrFolder {
    fn into_dart(self) -> support::DartAbi {
        match self {
            Self::File(field0) => vec![0.into_dart(), field0.into_dart()],
            Self::Folder(field0) => vec![1.into_dart(), field0.into_dart()],
        }
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for FileOrFolder {}

impl support::IntoDart for Idiom {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.idiom.into_dart(),
            self.pinyin.into_dart(),
            self.pinyin_tone.into_dart(),
            self.meaning.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for Idiom {}

impl support::IntoDart for NativeSysInfo {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.cpu.into_dart(),
            self.memory.into_dart(),
            self.t.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for NativeSysInfo {}

impl support::IntoDart for PracticeStatus {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.hit.into_dart(),
            self.current.into_dart(),
            self.practice_id.into_dart(),
            self.create_at.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for PracticeStatus {}

impl support::IntoDart for VirtualFile {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.file_id.into_dart(),
            self.virtual_path.into_dart(),
            self.real_path.into_dart(),
            self.file_type.into_dart(),
            self.icon.into_dart(),
            self.open_with.into_dart(),
            self.create_at.into_dart(),
            self.is_deleted.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for VirtualFile {}

impl support::IntoDart for VirtualFolder {
    fn into_dart(self) -> support::DartAbi {
        vec![
            self.folder_id.into_dart(),
            self.create_at.into_dart(),
            self.is_deleted.into_dart(),
            self.folder_name.into_dart(),
        ]
        .into_dart()
    }
}
impl support::IntoDartExceptPrimitive for VirtualFolder {}

// Section: executor

support::lazy_static! {
    pub static ref FLUTTER_RUST_BRIDGE_HANDLER: support::DefaultHandler = Default::default();
}

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "bridge_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;

#[cfg(not(target_family = "wasm"))]
#[path = "bridge_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;
